# C++

이제부터 42seoul 본과정에서는 더이상 C를 쓰지 않는다. C++을 적극활용해보자!

아래는 C++을 공부하며 개인적으로 특기할 점을 메모한 것이다.

## 구조체 vs 클래스

C에서 이미 구조체로 연관있는 데이터를 하나로 묶어서, 구현 및 관리를 편하게 했던 적이 있다.  그러나 C에서 구조체는 단순히 변수간의 관계만을 표현하므로, 그 구조체에만 연관되고 영향을 끼치는 '사실상 구조체에 종속적인 함수'들을 구조체에 속하게 할 수는 없다. 함수들은 여전히 전역적으로 쓰이며 엉뚱한 영역에서 이 함수가 호출되어 영향을 끼치는 상황이 충분히 생길 수 있다.

C++에서는 구조체안에 함수를 선언,정의하여 이런 문제를 방지할 수 있다. 그리고 구조체를 확인할 때 **1) 선언되어 있는 변수정보 2) 정의되어 있는 함수정보**를 한번에 확인할 수 있도록 함수의 정의만 구조체 안에 넣어두고, 정의는 구조체 밖으로 빼내는 것이 가독성에 도움된다. 단, 구조체 안에 구현되어있는 함수는 `inline`으로 처리되는 것을 더불어 내포되므로, 구조체 밖에서 함수를 정의할 때도 동일하게 처리되도록 하려면 `inline`으로 정의해야할 것이다. 

C++의 구조체는 클래스의 일종이다. 따라서 구조체와 클래스는 모두 접근제어 지시자의 선언이 가능하고 그 의미도 동일하다. 다만, 접근제어 지시자를 선언하지 않았을 때 클래스는 private으로, 구조체는 public으로 선언할 뿐이다.

### 접근제어 지시자(접근제어 레이블)

다음 3가지가 있다.

- public: 어디서든 접근허용

- protected: 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용

- private: 클래스 내에서만 접근허용

  

## 객체지향 프로그래밍

클래스는 구조체를 확장한 것이라고 단순히 이해하기에는 부족함이 있고, 객체지향적 관점에서 특성을 이해해야한다.

> 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍이다.

즉, 객체지향은 사람이 세상을 이해하는 관점 중에 하나이다. 객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성된다. 흔히 데이터는 변수에 담기고 행동은 함수 형태로 표현된다.

## 기타 팁

- 인라인 함수를 쓴다면, '컴파일 과정에서 함수의 호출 문이 있는 곳에 함수의 몸체 부분이 삽입되어야 하므로' 컴파일러가 클래스의 선언과 동시에 참조할 수 있도록 같은 파일에 저장해야한다. *컴파일러는 파일단위로 컴파일하기 때문이다.*
- [C++ 코딩컨벤션](https://jongwook.kim/google-styleguide/trunk/cppguide.xml)



# CPP Module00

키워드: 클래스, private vs public, 기본입출력

---

### 정적 멤버 변수

정적멤버변수는 클래스 내에서의 전역변수 개념이라고 생각하면 된다. 즉, 하나의 정적멤버변수는 같은 클래스 내의 모든 객체가 공용으로 사용할 수 있다.

정적멤버변수는 해당 클래스명으로 접근해야하며, private 정적멤버변수는 정적멤버함수로 접근한다.

[참고](https://m.blog.naver.com/PostView.nhn?blogId=star7sss&logNo=220809716792&proxyReferer=https:%2F%2Fwww.google.com%2F)



# CPP Module01

키워드: 스트링스트림, const, 참조변수



메모리 구조에 대해 간단복습.

프로그램을 만들고 실행을 하면 메모리에 코드들이 올라가 실행된다.

메모리는 아래 두 가지로 나눌 수 있다.

- 물리적 메모리
  - RAM이다. 
  - OS는 프로그램을 실행할 때 필요한 최소정보만 RAM에 저장한다. 이를 Woking set이라고 한다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은 것을 **프레임(Frame)**이라고 한다.
- 가상 메모리
  - HDD의 용량에서 가져와서 사용한다.
  - 일반적으로 코드를 실행하면 가상메모리에 적재된다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은것을 **페이지(Page)**라고 한다.

프로그램을 실행하면 필요한 데이터 정보를 가상 메모리에서 가져와서 상황에 맞게 물리적 메모리에 맵핑하고, 맵핑을 해제하기를 반복한다. 이를 **페이징 기법**이라고 한다. 페이징 기법으로 맵핑할 때는 같은 크기의 프레임과 페이지를 대응해서 맵핑한다. 너무 작은 데이터 단위로 페이징 기법이 작동하면 CPU에 부담을 주기 때문이다.

![image](https://user-images.githubusercontent.com/54612343/90375774-60231800-e0b0-11ea-83a3-242f2cdf3730.png)

기본 메모리 구조는 위와 같은데, 스택 영역에 적재되는 메모리는 큰 주소값을 시작으로 주소값이 작아지는 식으로 작동하고, 힙 영역에 적재되는 메모리는 작은 주소값을 시작으로 주소값을 증가시키는 식으로 작동한다. 요건 커널 영역에 '버퍼오보플로우'하여 데이터를 조작하는 것을 막기 위함이다. *왜 스택은 아래로, 버퍼는 위로 자라나는가 궁금했는데 요런 이유가 있었다.*

[참고](https://hwan-shell.tistory.com/13)



## stringStream

스트림은 입출력을 추상화해서 나타낸 것이다. 그럼 스트링스트림은? 문자열과 스트림의 기능이 동시에 존재하는 것이라고 보면 편하다.

> 스트림에서 cin(istream)은 사용자로부터 입력받고, ifstream은 파일로부터 입력을 받았다면, 이 stringstream은 문자열로부터 입력을 받는 것이다. 그리고  iostream 클래스를 상속받았기 떄문에, iostream에 있는 모든 함수나 연산자를 다 쓸 수 가 있다. 

이 [링크](https://m.blog.naver.com/kks227/220245263973)를 참고하자.



# const

C++에서도 C와 마찬가지로, const는  상수라는 의미이다. 즉, 데이터의 초기화가 이뤄지면 그 값을 바꿀 수 없도록 해준다. const를 선언한 변수는 '데이터 영역'에 들어가게 되며 컴파일과 동시에 데이터 영역 메모리로 올라가 버린다.

const 함수의 초기화는 1) 선언과 동시에 초기화 해주거나 2) 멤버 이니셜라이저 를 통해 가능하다.

헷갈릴 수 있는 부분을 정리하자면 아래와 같다.

#### 포인터에 쓰일 때 상수화되는 범위

1. `const int *ptr` : ptr 변경 가능, ptr이 가리키는 데이터는 변경 불가
2. `int const *ptr`:  ptr 변경 가능, ptr이 가리키는 데이터는 변경 불가
3. `int *const ptr`: ptr 변경 불가, ptr이 가리키는 데이터는 변경 가능
4. `const int const *ptr` : ptr 변경 불가, ptr이 가리키는 데이터도 변경 불가

#### 함수 파라미터에서 const 참조

함수 안에서 변경을 절대 하지 않겠다는 의미. 혹시 const 없이 &참조만 하면 함수안에서 원본과 같이 변경될 수 있으므로 주의하자.

#### 클래스 메서드 const

메서드를 const로 선언한다면 그 함수 안에서는 mutable로 선언된 변수를 제외하고 아무것도 변경할 수 없다. 보통 get함수 구현할 때 많이 사용한다.



! const 선언여부도 함수 오버로딩의 조건에 해당된다.





## 참조변수

- 참조형은 참조하는 값과 동일하게 작동한다. 따라서 참조되는 객체의 별칭으로 사용된다.

- 참조형은 선언과 동시에 반드시 초기화해야한다. 

- 초기화된 후에는 다른 변수를 참조하도록 변경할 수 없다.
- non-const 값에 대한 참조는 non-const 값으로만 초기화할 수 있다.
- 참조형은 함수 매개변수로 가장 많이 사용된다. 이 때 매개 변수는 인수의 별칭으로 사용되며, 복사본이 만들어지지 않는다. 마치 포인터를 매개변수 받을 때처럼, 전달된 참조형 매개변수로 인수를 수정할 수 있다.

#### References vs Pointers

참조형은 내부적으로 포인터를 사용하여 컴파일러단에서 구현된다. 참조형은 선언과 동시에 유요한 객체로 초기화해야하고, 일단 초기화되면 변경할 수 없으므로 포인터보다 사용하는 것이 훨씬 안전하다.



## C++에서의 static

static 변수는 전역변수와 같이 초기화되지 않은 경우엔 ''.bass variable' 메모리 영역에서, 초기화된 경우엔 'data variable' 메모리 영역에 저장된다.

C++에서는 static 변수의 이런 특성을 세가지 다른 용도로 사용한다. 

1. 클래스 내의 static 멤버, 함수
   - static 멤버 변수와 함수는 객체별로 따로 존재하지 않는다. 모든 객체에 공통으로 존재한다.
   - static 멤버 함수는 해당 클래스와 유사한 작업을 하거나 딱히 객체와 연관없는 일을 처리할 때 유용하다. 예를 들어, 암호화 및 인코딩을 해주는 클래스가 있다.
2. static 링킹
   - 소스파일을 컴파일하여 오브젝트 파일들을 만들고, 오브젝트 파일들을 하나로 링킹하여 실행파일을 만들어낼 때,  함수나 변수 이름을 기준으로 함수 호출, 변수 참조 등을 연결한다. 이 때 같은 소스 파일 안에서 연결되는 것을 '내부링킹'이라 하고, 외부 소스파일과 연결하는 것을 '외부 링킹'이라고 한다. 일반적인 함수나 전역변수는 외부링킹이 적용되지만 명시적으로 static을 적용하여 내부링킹으로 만들 수 있다.
   - C++에서는 내부링킹을 위해 함수마다 static을 붙이는 것을 대신하기 위해 **무명 네임스페이스**를 도입했다.
3. 함수 내 static 변수
   - static 로컬 변수는 함수가 끝난 뒤에도 계속 상태가 유지된다.



## C++에서의 파일 입출력

#### 파일읽기

<fstream> 헤더에 속한 ifstream 클래스를 쓴다. ifstream은 Input file stream의 줄임말로, 파일로부터 read한 내용을 프로그램에 입력할 수 있게 도와주는 클래스이다.

클래스 내 함수들 중 자주 쓸만한 것들은 아래와 같다.

1. `open` : 파일 열 때 사용
2. `is_open` : 파일 열렸는지 확인할 때 사용
3. `close`: 열린 파일 닫아줄 때 사용
4. `get`: 파일에서 char 한 단위씩 읽어올 때 사용
5. `getline`: 파일에서 한 라인씩 읽어올 때 사용. 
   - 그런데 <string> 헤더에 속한 `std::getline`이 string 타입으로 읽을 수 있어서 사용하기 편하다.
6. `eof`: 파일의 끝이 나오면 true를 반환, 아니면 false를 반환.

#### 파일쓰기

<fstream>헤더에 속한 ofstream 클래스를 쓰낟. ofstream은 Output file stream의 줄임말로, 프로그램의 출력을 file에 할 수 있게 돕는 클래스이다.

ifstream과 겹치지 않는 것 중에 자주 쓸만한 것은 아래와 같다.

1. write 함수
   - 원형: `ostream& write(const char *str, streamsize n);`
   - 첫번째 매개변수로 받은 캐릭터 포인터 타입의 문자열의 n만큼의 길이만큼 파일에 write하는 함수.

[참고](https://blockdmask.tistory.com/322)



## Tips

#### ex07

읽어오는 파일의 끝에 개행이 붙은 경우와 붙지 않은 경우를 나눠서 처리하자.





# CPP_Module02

키워드: 고정소수점, 복사생성자, 연산자 오버로딩

---

아하.. 고정소수점을 써야하는 과제가 나왔다! 문제에서 주어진 고정소수점 관련 아티클 ([1](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html) , [2](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html) , [3](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_printing.html) , [4](https://inst.eecs.berkeley.edu//~cs61c/sp06/handout/fixedpt.html))을 참고하자.

#### 고정소수점 vs 부동소수점

고정소수점은 실수를 2진법으로 변환하고, 메모리 비트영역을 1) 부호 2)정수부 3)소수부로 나누어서 실수를 표현한다.

구현하기 편리하지만 사용하는 비트 수 대비 표현 가능한 수의 범위 또는 정밀도(precision)가 낮다.

부동소수점은 두 단계로 나누어서 표현한다.

1. 정규화
   - 여기서 정규화는 실수를 '1.xxxx * 2^n' 꼴로 변환하는 것을 말한다.
2. IEEE 754 부동소수점 표현 의 과정을 거쳐서 실수를 표현한다.



## Canonical Class

정석적인 클래스를 뜻한다. 

C++11 이전과 이후로 나뉜다.

#### C++11 이전

- A default Constructor: 객체 생성시 객체와 데이터멤버 초기화
- A copy Constructor
- An assignment operator
- A destructor

#### C++11 이후

C++이전 캐노니컬폼에 아래 두 요소를 추가한 형태이다.

- Move constructor
- Move assignment operator

Canonical Class를 만들지 않으면 어떻게 될까? Caninical Class를 만들지 않는 바람에 소멸자나 복사생성자를 따로 선언해주지 않은 상태를 가정해보자. 그럼 객체가 소멸할 때나 객체를 복사할 때 컴파일러가 만들어주는 'default 소멸자', 'default 복사생성자'가 생성되어 활용된다.

문제는 default 복사생성자가 '얕은 복사'를 하기 때문에 문제가 발생할 소지가 있다는 것이다.

#### '깊은 복사'와 '얕은 복사'

default 복사생성자의 경우 멤버 대 멤버의 복사를 진행하며 이는 '얕은 복사(shallow copy)'라 한다. 이는 멤버변수가 힙의 메모리 공간을 참조하는 경우에 문제가 된다.

예를 들어 아래처럼 `class A`가 생성자에서 멤버변수 `char *name_`에 동적할당한 메모리를 가리키도록 하자. 소멸자에서는 동적할당한 `char *name_`을 할당해제해준다. 그리고 따로 복사생성자가 설정되어있지 않다.

```
class A
{
private:
    char *name_;
public:
	A(char *myName);
	{
		int len = strlen(myName);
		name_ = new char[len];
		strcpy(name_, myName);
	}
	~A()
	{
		delete []name;
	}
}
```

이 때 아래처럼 class A의 객체 a를 만든 뒤, 객체 b로 복사하면, 객체 b도 a객체의 멤버변수 name_과 동일한 주소를 가리키는 멤버변수를 가지게 된다. 이 상태에서 프로그램이 종료되면서 두 객체 a와 객체 b의 소멸자가 각각 호출될 때 문제가 생긴다. 

객체 a와 객체 b 모두 멤버변수로 '동일한 메모리주소'를 가리키고 있는 `char *name_` 을 가지고 있고, 소멸자에서 이 멤버변수가 가리키고 있는 메모리를 할당해제하게 되는데, 두 객체 중 하나가 소멸자를 호출하여 이미 메모리를 할당해제한 상태에서 다른 객체의 소멸자가 호출되면 이미 할당된 메모리를 또 할당해제하려고 할 것이기 때문이다.

이를 막으려면 '깊은 복사'를 해야한다.

```c++
int main()
{
    A a("iwoo");
	A b = a;
   
    return (0);
}

```

깊은 복사는 아래처럼 복사생성자를 명시적으로 적어주면된다.

```
A(const A& copy)
{
	name_ = new char[strlen(copy.name_)+1];
	strcpy(name_, copy.name_);
}
```



## 복사생성자 호출시점

**객체를 새로 생성하는데, 생성과 동시에 동일한 자료형의 객체로 초기화하는 경우**에 호출된다.

1. 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우
2. Call-by-value 방식의 함수호출 과정에서 객체를 인자로 전달하는 경우
3. 객체를 반환하되, 참조형으로 반환하지 않는 경우

[참고](https://www.francescmm.com/orthodox-canonical-class-form/)



## 연산자 오버로딩

간단하다. 연산자 오버로딩에는 두 가지 방법이 있다.

- 멤버함수에 의한 연산자 오버로딩
  - 객체 pos1과 pos2 가 있다고 했을 때 `pos1+pos2`를 입력하면, `pos1.operator+(pos2)`로 치환하여 실행한다.
- 전역함수에 의한 연산자 오버로딩
  - 객체 pos1과 pos2가 있다고 했을 때 `pos1+pos2`를 입력하면, `operator+(pos1, pos2)`로 치환하여 실행한다.

멤버함수 기반으로 오버로딩된 함수가 전역함수 기반으로 오버로딩 된 함수보다 우선시 되어 호출된다. 특별한 경우가 아니면 멤버함수를 기반으로 연산자를 오버로딩 하는게 낫다.

전역함수로 연산자 오버로딩하는 경우는 '교환법칙'을 성립하게하기 위한 경우가 대표적이다.

#### 오버로딩이 불가능한 연산자의 종류

아래 연산자들은 C++ 문법규칙을 보존하기 위해 오버로딩이 불가능하다.

- . 멤버접근연산자
- .* 멤버 포인터 연산자
- :: 범위 지정 연산자
- ?: 조건 연산자(3항 연산자)
- sizeof : 바이트 단위 크기 계산
- typeid: RTTI 관련 연산자
- static_cast : 형변환 연산자
- dynamic_cast: 형변환 연산자
- const_cast: 형변환 연산자
- reinterpret_cast: 형변환 연산자

#### 기타 룰

- 연산자의 우선순위와 결합성은 바뀌지 않는다.
- 매개변수의 디폴트 값 설정이 불가능하다.
- 연산자의 순수 기능까지 뺴앗을 수 없다.



# CPP Module03

키워드: 상속(inheritance), 가상(virtual)

---

## 상속이란?

기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미한다. 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다!

A클래스를 B클래스가 상속하면 그 관계를 일컫는 말은 많지만, 일반적으로는 A클래스는 기초클래스(Base class), B클래스는 유도클래스(derived class)라고 한다. 유도클래스는 기초클래스의 멤버들을 포함하게 된다. 유도클래스 객체가 생성되면 그 안에 기초클래스의 멤버변수와 유도클래스의 멤버변수가 존재하게된다는 건데! 때문에 **유도클래스의 생성자는 자신이 상속한 기초클래스의 멤버를 초기화할 의무를 지닌다.**

그리고 기초클래스의 멤버를 초기화하는 것은 유도클래스 생성자에서 **기초클래스 생성자를 호출하는 것이 안정적**이다.

- 유도클래스 생성시 생성자 호출순서
  1. 기초클래스 생성자 호출
  2. 유도클래스 생성자 호출
- 유도클래스 소멸시 소멸자 호출순서
  1. 유도클래스 소멸자 호출
  2. 기초클래스 소멸자 호출

요 특성에 따라 생성자에서 동적할당한 것은 소멸자에서 할당해제해주도록 하자.

## 접근제어 지시자(private vs protected vs public)

c++의 접근제어 지시자는 private, protected, public으로 구성되어있다.

- private: 해당 클래스 내부에서 접근 가능
- protected: 해당 클래스 내부, 유도 클래스 내부에서 접근 가능
- public: 해당 클래스 외부에서 접근 가능

기본적으로 기초 클래스와 이를 상속하는 유도 클래스 사이에서도 정보은닉성을 지켜준다는 차원에서 protected보다 private를 쓰는 것이 더 바람직하다.

위 접근제어 지시자는 상속할 때 상속의 형태를 명시하는 용도로도 사용된다.

- private 상속: private보다 접근의 범위가 넓은 멤버는 private로 변경시켜서 상속
- protected 상속: protected보다 접근의 범위가 넓은 멤버는 protected로 변경시켜서 상속
- public 상속: public보다 접근의 범위가 넓은 멤버는 public으로 변경시켜서 상속. 즉, private는 접근불가하도록, private를 제외한 나머지는 그냥 그대로 상속한다.

다중 상속할 때 빼고는 거진 public 상속을 하는게 보통이다.



## 가상함수

가상함수는 c++의 개념이 아니라 객체지향의 개념이다. 

특정 객체를 가리키는 포인터에는 그 객체타입의 주소나 그 객체와 상속관계에 있는 객체의 주소를 담을 수 있다. 이후 이 포인터를 이용하여 함수호출 시에는 포인터의 자료형을 기반으로 호출대상을 결정한다.

반면 함수가 가상함수로 선언되면, 해당 함수호출 시 포인터의 자료형을 기반으로 호출대상을 결정하지 않고, 포인터 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다.

가상함수로 선언된 함수를 오버라이딩하는 함수도 가상함수로 선언된다.

한편 객체의 소멸과정에서는 delete 연산자에 사용된 포인터 변수의 자료형에 상관없이 모든 소멸자가 호출되어야 한다. 이를 위해서는 소멸자에 virtual을 붙인 '가상 소멸자'를 선언할 필요가 있다.  역시 기초 클래스의 소멸자만 virtual로 선언해도 이를 상속하는 유도 클래스의 소멸자들도 모두 '가상 소멸자'로 선언된다.

**가상 소멸자가 호출되면, 상속의 계층구조상 맨 아래에 존재하는 유도 클래스의 소멸자가 대신 호출되면서, 기초 클래스의 소멸자가 순차적으로 호출된다.**

#### 순수 가상함수와 추상 클래스

순수 가상함수: 함수의 몸체가 정의되지 않은 함수. 특정 클래스로 객체를 생성하는 것을 금지하기 위해 쓰인다. 아래처럼 0을 대입시키는 형태로 표현하여 '명시적으로 몸체를 정의하지 않았음'을 컴파일러에게 알린다.

```
virtual int GetPay() const = 0; //순수 가상함수
```

이렇게 하나 이상의 함수를 순수 가상함수로 선언한 클래스를 가리켜 '추상 클래스(abstract class)'라 한다.