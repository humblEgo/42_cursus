# C++

이제부터 42seoul 본과정에서는 더이상 C를 쓰지 않는다. C++을 적극활용해보자!

아래는 C++을 공부하며 개인적으로 특기할 점을 메모한 것이다.

## 구조체 vs 클래스

C에서 이미 구조체로 연관있는 데이터를 하나로 묶어서, 구현 및 관리를 편하게 했던 적이 있다.  그러나 C에서 구조체는 단순히 변수간의 관계만을 표현하므로, 그 구조체에만 연관되고 영향을 끼치는 '사실상 구조체에 종속적인 함수'들을 구조체에 속하게 할 수는 없다. 함수들은 여전히 전역적으로 쓰이며 엉뚱한 영역에서 이 함수가 호출되어 영향을 끼치는 상황이 충분히 생길 수 있다.

C++에서는 구조체안에 함수를 선언,정의하여 이런 문제를 방지할 수 있다. 그리고 구조체를 확인할 때 **1) 선언되어 있는 변수정보 2) 정의되어 있는 함수정보**를 한번에 확인할 수 있도록 함수의 정의만 구조체 안에 넣어두고, 정의는 구조체 밖으로 빼내는 것이 가독성에 도움된다. 단, 구조체 안에 구현되어있는 함수는 `inline`으로 처리되는 것을 더불어 내포되므로, 구조체 밖에서 함수를 정의할 때도 동일하게 처리되도록 하려면 `inline`으로 정의해야할 것이다. 

C++의 구조체는 클래스의 일종이다. 따라서 구조체와 클래스는 모두 접근제어 지시자의 선언이 가능하고 그 의미도 동일하다. 다만, 접근제어 지시자를 선언하지 않았을 때 클래스는 private으로, 구조체는 public으로 선언할 뿐이다.

### 접근제어 지시자(접근제어 레이블)

다음 3가지가 있다.

- public: 어디서든 접근허용

- protected: 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용

- private: 클래스 내에서만 접근허용

  

## 객체지향 프로그래밍

클래스는 구조체를 확장한 것이라고 단순히 이해하기에는 부족함이 있고, 객체지향적 관점에서 특성을 이해해야한다.

> 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍이다.

즉, 객체지향은 사람이 세상을 이해하는 관점 중에 하나이다. 객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성된다. 흔히 데이터는 변수에 담기고 행동은 함수 형태로 표현된다.

## 기타 팁

- 인라인 함수를 쓴다면, '컴파일 과정에서 함수의 호출 문이 있는 곳에 함수의 몸체 부분이 삽입되어야 하므로' 컴파일러가 클래스의 선언과 동시에 참조할 수 있도록 같은 파일에 저장해야한다. *컴파일러는 파일단위로 컴파일하기 때문이다.*
- [C++ 코딩컨벤션](https://jongwook.kim/google-styleguide/trunk/cppguide.xml)



# CPP Module00

### 정적 멤버 변수

정적멤버변수는 클래스 내에서의 전역변수 개념이라고 생각하면 된다. 즉, 하나의 정적멤버변수는 같은 클래스 내의 모든 객체가 공용으로 사용할 수 있다.

정적멤버변수는 해당 클래스명으로 접근해야하며, private 정적멤버변수는 정적멤버함수로 접근한다.

[참고](https://m.blog.naver.com/PostView.nhn?blogId=star7sss&logNo=220809716792&proxyReferer=https:%2F%2Fwww.google.com%2F)



# CPP Module01

메모리 구조에 대해 간단복습.

프로그램을 만들고 실행을 하면 메모리에 코드들이 올라가 실행된다.

메모리는 아래 두 가지로 나눌 수 있다.

- 물리적 메모리
  - RAM이다. 
  - OS는 프로그램을 실행할 때 필요한 최소정보만 RAM에 저장한다. 이를 Woking set이라고 한다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은 것을 **프레임(Frame)**이라고 한다.
- 가상 메모리
  - HDD의 용량에서 가져와서 사용한다.
  - 일반적으로 코드를 실행하면 가상메모리에 적재된다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은것을 **페이지(Page)**라고 한다.

프로그램을 실행하면 필요한 데이터 정보를 가상 메모리에서 가져와서 상황에 맞게 물리적 메모리에 맵핑하고, 맵핑을 해제하기를 반복한다. 이를 **페이징 기법**이라고 한다. 페이징 기법으로 맵핑할 때는 같은 크기의 프레임과 페이지를 대응해서 맵핑한다. 너무 작은 데이터 단위로 페이징 기법이 작동하면 CPU에 부담을 주기 때문이다.

![image](https://user-images.githubusercontent.com/54612343/90375774-60231800-e0b0-11ea-83a3-242f2cdf3730.png)

기본 메모리 구조는 위와 같은데, 스택 영역에 적재되는 메모리는 큰 주소값을 시작으로 주소값이 작아지는 식으로 작동하고, 힙 영역에 적재되는 메모리는 작은 주소값을 시작으로 주소값을 증가시키는 식으로 작동한다. 요건 커널 영역에 '버퍼오보플로우'하여 데이터를 조작하는 것을 막기 위함이다. *왜 스택은 아래로, 버퍼는 위로 자라나는가 궁금했는데 요런 이유가 있었다.*

[참고](https://hwan-shell.tistory.com/13)

