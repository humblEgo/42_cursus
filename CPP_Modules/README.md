# C++

이제부터 42seoul 본과정에서는 더이상 C를 쓰지 않는다. C++을 적극활용해보자!

아래는 C++을 공부하며 개인적으로 특기할 점을 메모한 것이다.

## 구조체 vs 클래스

C에서 이미 구조체로 연관있는 데이터를 하나로 묶어서, 구현 및 관리를 편하게 했던 적이 있다.  그러나 C에서 구조체는 단순히 변수간의 관계만을 표현하므로, 그 구조체에만 연관되고 영향을 끼치는 '사실상 구조체에 종속적인 함수'들을 구조체에 속하게 할 수는 없다. 함수들은 여전히 전역적으로 쓰이며 엉뚱한 영역에서 이 함수가 호출되어 영향을 끼치는 상황이 충분히 생길 수 있다.

C++에서는 구조체안에 함수를 선언,정의하여 이런 문제를 방지할 수 있다. 그리고 구조체를 확인할 때 **1) 선언되어 있는 변수정보 2) 정의되어 있는 함수정보**를 한번에 확인할 수 있도록 함수의 정의만 구조체 안에 넣어두고, 정의는 구조체 밖으로 빼내는 것이 가독성에 도움된다. 단, 구조체 안에 구현되어있는 함수는 `inline`으로 처리되는 것을 더불어 내포되므로, 구조체 밖에서 함수를 정의할 때도 동일하게 처리되도록 하려면 `inline`으로 정의해야할 것이다. 

C++의 구조체는 클래스의 일종이다. 따라서 구조체와 클래스는 모두 접근제어 지시자의 선언이 가능하고 그 의미도 동일하다. 다만, 접근제어 지시자를 선언하지 않았을 때 클래스는 private으로, 구조체는 public으로 선언할 뿐이다.

### 접근제어 지시자(접근제어 레이블)

다음 3가지가 있다.

- public: 어디서든 접근허용

- protected: 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용

- private: 클래스 내에서만 접근허용

  

## 객체지향 프로그래밍

클래스는 구조체를 확장한 것이라고 단순히 이해하기에는 부족함이 있고, 객체지향적 관점에서 특성을 이해해야한다.

> 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화시키는 형태의 프로그래밍이다.

즉, 객체지향은 사람이 세상을 이해하는 관점 중에 하나이다. 객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성된다. 흔히 데이터는 변수에 담기고 행동은 함수 형태로 표현된다.

## 기타 팁

- 인라인 함수를 쓴다면, '컴파일 과정에서 함수의 호출 문이 있는 곳에 함수의 몸체 부분이 삽입되어야 하므로' 컴파일러가 클래스의 선언과 동시에 참조할 수 있도록 같은 파일에 저장해야한다. *컴파일러는 파일단위로 컴파일하기 때문이다.*
- [C++ 코딩컨벤션](https://jongwook.kim/google-styleguide/trunk/cppguide.xml)



# CPP Module00

키워드: 클래스, private vs public, 기본입출력

---

### 정적 멤버 변수

정적멤버변수는 클래스 내에서의 전역변수 개념이라고 생각하면 된다. 즉, 하나의 정적멤버변수는 같은 클래스 내의 모든 객체가 공용으로 사용할 수 있다.

정적멤버변수는 해당 클래스명으로 접근해야하며, private 정적멤버변수는 정적멤버함수로 접근한다.

[참고](https://m.blog.naver.com/PostView.nhn?blogId=star7sss&logNo=220809716792&proxyReferer=https:%2F%2Fwww.google.com%2F)



# CPP Module01

키워드: 스트링스트림, const, 참조변수



메모리 구조에 대해 간단복습.

프로그램을 만들고 실행을 하면 메모리에 코드들이 올라가 실행된다.

메모리는 아래 두 가지로 나눌 수 있다.

- 물리적 메모리
  - RAM이다. 
  - OS는 프로그램을 실행할 때 필요한 최소정보만 RAM에 저장한다. 이를 Woking set이라고 한다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은 것을 **프레임(Frame)**이라고 한다.
- 가상 메모리
  - HDD의 용량에서 가져와서 사용한다.
  - 일반적으로 코드를 실행하면 가상메모리에 적재된다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은것을 **페이지(Page)**라고 한다.

프로그램을 실행하면 필요한 데이터 정보를 가상 메모리에서 가져와서 상황에 맞게 물리적 메모리에 맵핑하고, 맵핑을 해제하기를 반복한다. 이를 **페이징 기법**이라고 한다. 페이징 기법으로 맵핑할 때는 같은 크기의 프레임과 페이지를 대응해서 맵핑한다. 너무 작은 데이터 단위로 페이징 기법이 작동하면 CPU에 부담을 주기 때문이다.

![image](https://user-images.githubusercontent.com/54612343/90375774-60231800-e0b0-11ea-83a3-242f2cdf3730.png)

기본 메모리 구조는 위와 같은데, 스택 영역에 적재되는 메모리는 큰 주소값을 시작으로 주소값이 작아지는 식으로 작동하고, 힙 영역에 적재되는 메모리는 작은 주소값을 시작으로 주소값을 증가시키는 식으로 작동한다. 요건 커널 영역에 '버퍼오버플로우'하여 데이터를 조작하는 것을 막기 위함이다. *왜 스택은 아래로, 버퍼는 위로 자라나는가 궁금했는데 요런 이유가 있었다.*

[참고](https://hwan-shell.tistory.com/13)



## stringStream

스트림은 입출력을 추상화해서 나타낸 것이다. 그럼 스트링스트림은? 문자열과 스트림의 기능이 동시에 존재하는 것이라고 보면 편하다.

> 스트림에서 cin(istream)은 사용자로부터 입력받고, ifstream은 파일로부터 입력을 받았다면, 이 stringstream은 문자열로부터 입력을 받는 것이다. 그리고  iostream 클래스를 상속받았기 떄문에, iostream에 있는 모든 함수나 연산자를 다 쓸 수 가 있다. 

이 [링크](https://m.blog.naver.com/kks227/220245263973)를 참고하자.



# const

C++에서도 C와 마찬가지로, const는  상수라는 의미이다. 즉, 데이터의 초기화가 이뤄지면 그 값을 바꿀 수 없도록 해준다. const를 선언한 변수는 '데이터 영역'에 들어가게 되며 컴파일과 동시에 데이터 영역 메모리로 올라가 버린다.

const 함수의 초기화는 1) 선언과 동시에 초기화 해주거나 2) 멤버 이니셜라이저 를 통해 가능하다.

헷갈릴 수 있는 부분을 정리하자면 아래와 같다.

#### 포인터에 쓰일 때 상수화되는 범위

1. `const int *ptr` : ptr 변경 가능, ptr이 가리키는 데이터는 변경 불가
2. `int const *ptr`:  ptr 변경 가능, ptr이 가리키는 데이터는 변경 불가
3. `int *const ptr`: ptr 변경 불가, ptr이 가리키는 데이터는 변경 가능
4. `const int const *ptr` : ptr 변경 불가, ptr이 가리키는 데이터도 변경 불가

#### 함수 파라미터에서 const 참조

함수 안에서 변경을 절대 하지 않겠다는 의미. 혹시 const 없이 &참조만 하면 함수안에서 원본과 같이 변경될 수 있으므로 주의하자.

#### 클래스 메서드 const

메서드를 const로 선언한다면 그 함수 안에서는 mutable로 선언된 변수를 제외하고 아무것도 변경할 수 없다. 보통 get함수 구현할 때 많이 사용한다.



! const 선언여부도 함수 오버로딩의 조건에 해당된다.





## 참조변수

- 참조형은 참조하는 값과 동일하게 작동한다. 따라서 참조되는 객체의 별칭으로 사용된다.

- 참조형은 선언과 동시에 반드시 초기화해야한다. 

- 초기화된 후에는 다른 변수를 참조하도록 변경할 수 없다.
- non-const 값에 대한 참조는 non-const 값으로만 초기화할 수 있다.
- 참조형은 함수 매개변수로 가장 많이 사용된다. 이 때 매개 변수는 인수의 별칭으로 사용되며, 복사본이 만들어지지 않는다. 마치 포인터를 매개변수 받을 때처럼, 전달된 참조형 매개변수로 인수를 수정할 수 있다.

#### References vs Pointers

참조형은 내부적으로 포인터를 사용하여 컴파일러단에서 구현된다. 참조형은 선언과 동시에 유효한 객체로 초기화해야하고, 일단 초기화되면 변경할 수 없으므로 포인터보다 사용하는 것이 훨씬 안전하다.



## C++에서의 static

static 변수는 전역변수와 같이 초기화되지 않은 경우엔 ''.bass variable' 메모리 영역에서, 초기화된 경우엔 'data variable' 메모리 영역에 저장된다.

C++에서는 static 변수의 이런 특성을 세가지 다른 용도로 사용한다. 

1. 클래스 내의 static 멤버, 함수
   - static 멤버 변수와 함수는 객체별로 따로 존재하지 않는다. 모든 객체에 공통으로 존재한다.
   - static 멤버 함수는 해당 클래스와 유사한 작업을 하거나 딱히 객체와 연관없는 일을 처리할 때 유용하다. 예를 들어, 암호화 및 인코딩을 해주는 클래스가 있다.
2. static 링킹
   - 소스파일을 컴파일하여 오브젝트 파일들을 만들고, 오브젝트 파일들을 하나로 링킹하여 실행파일을 만들어낼 때,  함수나 변수 이름을 기준으로 함수 호출, 변수 참조 등을 연결한다. 이 때 같은 소스 파일 안에서 연결되는 것을 '내부링킹'이라 하고, 외부 소스파일과 연결하는 것을 '외부 링킹'이라고 한다. 일반적인 함수나 전역변수는 외부링킹이 적용되지만 명시적으로 static을 적용하여 내부링킹으로 만들 수 있다.
   - C++에서는 내부링킹을 위해 함수마다 static을 붙이는 것을 대신하기 위해 **무명 네임스페이스**를 도입했다.
3. 함수 내 static 변수
   - static 로컬 변수는 함수가 끝난 뒤에도 계속 상태가 유지된다.



## C++에서의 파일 입출력

#### 파일읽기

<fstream> 헤더에 속한 ifstream 클래스를 쓴다. ifstream은 Input file stream의 줄임말로, 파일로부터 read한 내용을 프로그램에 입력할 수 있게 도와주는 클래스이다.

클래스 내 함수들 중 자주 쓸만한 것들은 아래와 같다.

1. `open` : 파일 열 때 사용
2. `is_open` : 파일 열렸는지 확인할 때 사용
3. `close`: 열린 파일 닫아줄 때 사용
4. `get`: 파일에서 char 한 단위씩 읽어올 때 사용
5. `getline`: 파일에서 한 라인씩 읽어올 때 사용. 
   - 그런데 <string> 헤더에 속한 `std::getline`이 string 타입으로 읽을 수 있어서 사용하기 편하다.
6. `eof`: 파일의 끝이 나오면 true를 반환, 아니면 false를 반환.

#### 파일쓰기

<fstream>헤더에 속한 ofstream 클래스를 쓰낟. ofstream은 Output file stream의 줄임말로, 프로그램의 출력을 file에 할 수 있게 돕는 클래스이다.

ifstream과 겹치지 않는 것 중에 자주 쓸만한 것은 아래와 같다.

1. write 함수
   - 원형: `ostream& write(const char *str, streamsize n);`
   - 첫번째 매개변수로 받은 캐릭터 포인터 타입의 문자열의 n만큼의 길이만큼 파일에 write하는 함수.

[참고](https://blockdmask.tistory.com/322)



## Tips

#### ex07

읽어오는 파일의 끝에 개행이 붙은 경우와 붙지 않은 경우를 나눠서 처리하자.





# CPP_Module02

키워드: 고정소수점, 복사생성자, 연산자 오버로딩

---

아하.. 고정소수점을 써야하는 과제가 나왔다! 문제에서 주어진 고정소수점 관련 아티클 ([1](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html) , [2](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html) , [3](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_printing.html) , [4](https://inst.eecs.berkeley.edu//~cs61c/sp06/handout/fixedpt.html))을 참고하자.

#### 고정소수점 vs 부동소수점

고정소수점은 실수를 2진법으로 변환하고, 메모리 비트영역을 1) 부호 2)정수부 3)소수부로 나누어서 실수를 표현한다.

구현하기 편리하지만 사용하는 비트 수 대비 표현 가능한 수의 범위 또는 정밀도(precision)가 낮다.

부동소수점은 두 단계로 나누어서 표현한다.

1. 정규화
   - 여기서 정규화는 실수를 '1.xxxx * 2^n' 꼴로 변환하는 것을 말한다.
2. IEEE 754 부동소수점 표현 의 과정을 거쳐서 실수를 표현한다.



## Canonical Class

정석적인 클래스를 뜻한다. 

C++11 이전과 이후로 나뉜다.

#### C++11 이전

- A default Constructor: 객체 생성시 객체와 데이터멤버 초기화
- A copy Constructor
- An assignment operator
- A destructor

#### C++11 이후

C++이전 캐노니컬폼에 아래 두 요소를 추가한 형태이다.

- Move constructor
- Move assignment operator

Canonical Class를 만들지 않으면 어떻게 될까? Caninical Class를 만들지 않는 바람에 소멸자나 복사생성자를 따로 선언해주지 않은 상태를 가정해보자. 그럼 객체가 소멸할 때나 객체를 복사할 때 컴파일러가 만들어주는 'default 소멸자', 'default 복사생성자'가 생성되어 활용된다.

문제는 default 복사생성자가 '얕은 복사'를 하기 때문에 문제가 발생할 소지가 있다는 것이다.

#### '깊은 복사'와 '얕은 복사'

default 복사생성자의 경우 멤버 대 멤버의 복사를 진행하며 이는 '얕은 복사(shallow copy)'라 한다. 이는 멤버변수가 힙의 메모리 공간을 참조하는 경우에 문제가 된다.

예를 들어 아래처럼 `class A`가 생성자에서 멤버변수 `char *name_`에 동적할당한 메모리를 가리키도록 하자. 소멸자에서는 동적할당한 `char *name_`을 할당해제해준다. 그리고 따로 복사생성자가 설정되어있지 않다.

```
class A
{
private:
    char *name_;
public:
	A(char *myName);
	{
		int len = strlen(myName);
		name_ = new char[len];
		strcpy(name_, myName);
	}
	~A()
	{
		delete []name;
	}
}
```

이 때 아래처럼 class A의 객체 a를 만든 뒤, 객체 b로 복사하면, 객체 b도 a객체의 멤버변수 name_과 동일한 주소를 가리키는 멤버변수를 가지게 된다. 이 상태에서 프로그램이 종료되면서 두 객체 a와 객체 b의 소멸자가 각각 호출될 때 문제가 생긴다. 

객체 a와 객체 b 모두 멤버변수로 '동일한 메모리주소'를 가리키고 있는 `char *name_` 을 가지고 있고, 소멸자에서 이 멤버변수가 가리키고 있는 메모리를 할당해제하게 되는데, 두 객체 중 하나가 소멸자를 호출하여 이미 메모리를 할당해제한 상태에서 다른 객체의 소멸자가 호출되면 이미 할당된 메모리를 또 할당해제하려고 할 것이기 때문이다.

이를 막으려면 '깊은 복사'를 해야한다.

```c++
int main()
{
    A a("iwoo");
	A b = a;
   
    return (0);
}

```

깊은 복사는 아래처럼 복사생성자를 명시적으로 적어주면된다.

```
A(const A& copy)
{
	name_ = new char[strlen(copy.name_)+1];
	strcpy(name_, copy.name_);
}
```



## 복사생성자 호출시점

**객체를 새로 생성하는데, 생성과 동시에 동일한 자료형의 객체로 초기화하는 경우**에 호출된다.

1. 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우
2. Call-by-value 방식의 함수호출 과정에서 객체를 인자로 전달하는 경우
3. 객체를 반환하되, 참조형으로 반환하지 않는 경우

[참고](https://www.francescmm.com/orthodox-canonical-class-form/)



## 연산자 오버로딩

간단하다. 연산자 오버로딩에는 두 가지 방법이 있다.

- 멤버함수에 의한 연산자 오버로딩
  - 객체 pos1과 pos2 가 있다고 했을 때 `pos1+pos2`를 입력하면, `pos1.operator+(pos2)`로 치환하여 실행한다.
- 전역함수에 의한 연산자 오버로딩
  - 객체 pos1과 pos2가 있다고 했을 때 `pos1+pos2`를 입력하면, `operator+(pos1, pos2)`로 치환하여 실행한다.

멤버함수 기반으로 오버로딩된 함수가 전역함수 기반으로 오버로딩 된 함수보다 우선시 되어 호출된다. 특별한 경우가 아니면 멤버함수를 기반으로 연산자를 오버로딩 하는게 낫다.

전역함수로 연산자 오버로딩하는 경우는 '교환법칙'을 성립하게하기 위한 경우가 대표적이다.

#### 오버로딩이 불가능한 연산자의 종류

아래 연산자들은 C++ 문법규칙을 보존하기 위해 오버로딩이 불가능하다.

- . 멤버접근연산자
- .* 멤버 포인터 연산자
- :: 범위 지정 연산자
- ?: 조건 연산자(3항 연산자)
- sizeof : 바이트 단위 크기 계산
- typeid: RTTI 관련 연산자
- static_cast : 형변환 연산자
- dynamic_cast: 형변환 연산자
- const_cast: 형변환 연산자
- reinterpret_cast: 형변환 연산자

#### 기타 룰

- 연산자의 우선순위와 결합성은 바뀌지 않는다.
- 매개변수의 디폴트 값 설정이 불가능하다.
- 연산자의 순수 기능까지 빼앗을 수 없다.



# CPP Module03

키워드: 상속(inheritance), 가상(virtual)

---

## 상속이란?

기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미한다. 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다!

A클래스를 B클래스가 상속하면 그 관계를 일컫는 말은 많지만, 일반적으로는 A클래스는 기초클래스(Base class), B클래스는 유도클래스(derived class)라고 한다. 유도클래스는 기초클래스의 멤버들을 포함하게 된다. 유도클래스 객체가 생성되면 그 안에 기초클래스의 멤버변수와 유도클래스의 멤버변수가 존재하게된다는 건데! 때문에 **유도클래스의 생성자는 자신이 상속한 기초클래스의 멤버를 초기화할 의무를 지닌다.**

그리고 기초클래스의 멤버를 초기화하는 것은 유도클래스 생성자에서 **기초클래스 생성자를 호출하는 것이 안정적**이다.

- 유도클래스 생성시 생성자 호출순서
  1. 기초클래스 생성자 호출
  2. 유도클래스 생성자 호출
- 유도클래스 소멸시 소멸자 호출순서
  1. 유도클래스 소멸자 호출
  2. 기초클래스 소멸자 호출

요 특성에 따라 생성자에서 동적할당한 것은 소멸자에서 할당해제해주도록 하자.

## 접근제어 지시자(private vs protected vs public)

c++의 접근제어 지시자는 private, protected, public으로 구성되어있다.

- private: 해당 클래스 내부에서 접근 가능
- protected: 해당 클래스 내부, 유도 클래스 내부에서 접근 가능
- public: 해당 클래스 외부에서 접근 가능

기본적으로 기초 클래스와 이를 상속하는 유도 클래스 사이에서도 정보은닉성을 지켜준다는 차원에서 protected보다 private를 쓰는 것이 더 바람직하다.

위 접근제어 지시자는 상속할 때 상속의 형태를 명시하는 용도로도 사용된다.

- private 상속: private보다 접근의 범위가 넓은 멤버는 private로 변경시켜서 상속
- protected 상속: protected보다 접근의 범위가 넓은 멤버는 protected로 변경시켜서 상속
- public 상속: public보다 접근의 범위가 넓은 멤버는 public으로 변경시켜서 상속. 즉, private는 접근불가하도록, private를 제외한 나머지는 그냥 그대로 상속한다.

다중 상속할 때 빼고는 거진 public 상속을 하는게 보통이다.



## 가상함수

가상함수는 c++의 개념이 아니라 객체지향의 개념이다. 

특정 객체를 가리키는 포인터에는 그 객체타입의 주소나 그 객체와 상속관계에 있는 객체의 주소를 담을 수 있다. 이후 이 포인터를 이용하여 함수호출 시에는 포인터의 자료형을 기반으로 호출대상을 결정한다.

반면 함수가 가상함수로 선언되면, 해당 함수호출 시 포인터의 자료형을 기반으로 호출대상을 결정하지 않고, 포인터 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다.

가상함수로 선언된 함수를 오버라이딩하는 함수도 가상함수로 선언된다.

한편 객체의 소멸과정에서는 delete 연산자에 사용된 포인터 변수의 자료형에 상관없이 모든 소멸자가 호출되어야 한다. 이를 위해서는 소멸자에 virtual을 붙인 '가상 소멸자'를 선언할 필요가 있다.  역시 기초 클래스의 소멸자만 virtual로 선언해도 이를 상속하는 유도 클래스의 소멸자들도 모두 '가상 소멸자'로 선언된다.

**가상 소멸자가 호출되면, 상속의 계층구조상 맨 아래에 존재하는 유도 클래스의 소멸자가 대신 호출되면서, 기초 클래스의 소멸자가 순차적으로 호출된다.**

가상함수의 자세한 원리는 가상함수 테이블을 키워드로 찾아보자.

#### 순수 가상함수와 추상 클래스

순수 가상함수: 함수의 몸체가 정의되지 않은 함수. 특정 클래스로 객체를 생성하는 것을 금지하기 위해 쓰인다. 아래처럼 0을 대입시키는 형태로 표현하여 '명시적으로 몸체를 정의하지 않았음'을 컴파일러에게 알린다.

```
virtual int GetPay() const = 0; //순수 가상함수
```

이렇게 하나 이상의 함수를 순수 가상함수로 선언한 클래스를 가리켜 '추상 클래스(abstract class)'라 한다.



# 다중상속

다중상속이란 둘 이상의 클래스를 동시에 상속하는 것을 말한다. 다중상속으로만 풀 수 있는 문제가 드물고 복잡도를 높이는데 일조한다는 점에서 논란이 되는 문법이다.(*실제로 자바에서는 이런 이유에서 클래스 다중상속을 허용하지 않는다.*) c++에서는 다중상속시 참조할 대상이 모호해지는 문제를 네임스페이스를 명시함으로써 해결한다. 

한편 특정 기초클래스 A를 상속한 두 유도클래스 B와 C가 있을 때, B와 C를 다중상속하는 유도클래스 D가 있다고 가정하면, D 클래스 객체는 기초클래스 A를 간접적으로 두 번 상속하는 결과를 낳게 된다. 이럴 땐 기초클래스 A를 **가상상속**하여 딱 한번만 상속하게끔 하여 해결할 수 있다.



# CPP Module 04

키워드: 가상(virtual), 추상클래스(순수가상)

---

요는 업캐스팅된 객체의 함수에 어떻게 접근할지, 그 객체의 소멸자 처리를 어떻게 할지가 포인트이다! 가상의 강력함을 느낄 수 있는 모듈.

## Tips

#### ex03

- 과제문서를 보면 `class AMataria` 가 `AMataria.hpp`에 있고, `class ICharacter`가 `ICharacter.hpp`에 있는데, `class ICharacter`가 `class AMataria`를 사용하고, `class AMataria`가 `class ICharacter`를 사용하는.. 난감하게 설계된 상태이다. 
  다행히 `class ICharacter`에서는 AMataria 포인터만 쓰므로, 클래스 전방선언을 이용하여 해결하자.

  [참고](https://jrabbit.tistory.com/35)



# CPP Module 05

키워드: try-catch

---

C++에서 말하는 '예외(Exception)'는 프로그램의 실행 도중에 발생하는 문제상황을 의미한다. 따라서 컴파일 시 발생하는 **문법적인 에러는 예외에 포함되지 않는다,** 대신 **프로그램의 논리에 맞지 않는 상황이 예외**이다.

C와 달리 C++에서는 try, catch, throw, finally 같은 구문을 통해 구조적으로 예외를 처리할 수 있는 메커니즘을 제공하는데, 이를 통해 코드의 가독성과 유지보수성을 높인다.

*대박.. 함수 스택이 깊어졌을 때 malloc 오류라도 처리하려면 하나하나 return 을 해주면서 예외를 처리했어야했는데 이제 훨씬 편해졌다!ㅎㅎ*

특기할만한 특징

- 예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가 (더불어 예외처리에 대한 책임까지) 전달된다.

- 함수가 여러번 호출되어 스택이 쌓였는데 마지막으로 실행된 함수에서 예외가 발생한다면, 스택이 하나씩 해제되며 호출한 함수에게 예외를 전달한다.

- 만약 반환된 예외를 처리하는 코드가 없다면 main문까지 스택이 풀리고 main문에서도 terminate 함수가 호출되면서 프로그램이 종료되어버린다.

- catch문 적힌 자료형과 throw된 예외의 자료형이 다르다면 catch문이 실행되지 않고, 그 함수를 호출한 영역으로 예외가 전달된다.

- catch문이 여러개일 경우 throw받은 예외를 처리할 수 있는 catch블록을 위에서부터 아래로 찾아내려간다.

- new 연산자에 의해서 발생하는 예외는 'bad_alloc'이라는 예외이다. 

- `catch(...)`처럼 작성하면 전달되는 모든 예외를 다 받아서 처리하게 된다.

- catch 블록에 전달된 예외는 다시 던져질 수 있다.

- 아래처럼 함수선언 뒤에 throw 란을 공란으로 두면 어떠한 예외도 전달하지 않음을 의미하며 이 함수가 예외를 전달하면 프로그램이 그냥 종료된다.

  ```c++
  int SimpleFunc(void) throw()
  {
  ...
  }
  ```

- try~catch문에서 '예외객체'를 throw한 경우엔 객체를 복사해서 던지므로 catch문에서 래퍼런스로 받는 것이 오버로드를 줄이는데 좋다.

- ❗**생성자에서 예외가 발생 시에는 소멸자가 호출되지 않는다!!!** 이 말은 예외를 던지기 이전에 획득한 자원이 있으면 `catch`에서 잘 해제시켜줘야한다.❗

#### try 블록을 묶는 기준

- try블록을 묶는 기준은 **예외가 발생할만한 영역을 묶는 것이 아니다.** 예외가 발생할만한 영역만 묶는 게 아니라, 그와 관련된 모든 문장을 함께 묶어서 이를 하나의 '일'의 단위로 구성하는 것이다. 

#### 전달되는 예외의 명시

특정 함수를 호출할 때 아래 정보들을 알아야한다.

- 함수의 이름
- 매개변수의 선언
- 반환형 정보
- 함수 내에서 전달될 수 있는 예외의 종류 <-- *그래야 해당 함수를 감싸는 적절한 try~catch 블록을 구성할 수 있다.*

#### 예외클래스와 예외객체

예외발생을 알리는데 사용되는 객체를 가리켜 '예외객체'라 하며, 예외객체의 생성을 위해 정의된 클래스를 '예외 클래스'라 한다. 그리고 객체를 이용해서 예외상황을 알리면, 예외가 발생한 원인에 대한 정보를 보다 자세히 담을 수 있다. 



## try~catch 문의 단점

1. 프로그램의 성능이 눈에 띄게 느려진다. <-- 때문에 무조건 발생할 수 있는 모든 예외를 처리하는 것이 아니라 적당한 타협점을 찾아야한다고 한다.
2. 프로그램 용량이 커지게 된다.
3. 전통적인 if-else문을 모두 바꿀 수 있는 것은 아니다.
4. throw로 갑자기 종료할 경우 이전에 동적할당한 메모리가 해제되지 않을 수도 있다.
5. 템플릿에는 쓸 수 없다.

[참고](https://modoocode.com/230)



## new 연산자 예외처리

두 가지 방식이 주로 쓰인다.

- new가 할당실패했을 때 bad_alloc 예외를 발생시키도록 두고, 이를 catch해서 처리하는 방식

  ```c++
  int main(void) {
         Temp * temp;
         try {
                temp = new Temp();
         }
         catch (std::bad_alloc & ba) {
                std::cout << ba.what();
         }
  }
  ```

- new의 인자로 std::nothrow를 전달하여 new가 할당실패했을 때 bad_alloc 예외를 throw하는게 아니라 nullptr를 리턴하도록 한다. 이후 이를 체크하여 처리하는 방식

  ```c++
  int main(void) {
         test * a = new (std::nothrow) test;
         if (a == nullptr) {
                std::cout << "할당 실패";
         }
  }
  ```



## 생성자에서 예외가 발생하면 어떻게 처리될까??

생성자에서 throw할 경우엔 어떻게 될까? 특히 상속된 유도클래스의 생성자가 기초클래스를 만든 상태에서 예외를 throw할 경우엔 어떻게 될까? 아아 뭔가 제대로 모르고 쓰면 큰일날 것만 같은 느낌이 들지 않는가?

실제로 생성자가 throw하는 경우는 그 생성자가 작동하던 객체가 '초기화에 실패한 클래스 객체'라는 것이다. 이 때 이 객체를 사용자가 사용하게 되면 또 오류가 나는 끔-찍한 일이 생기므로 꽤나 심각한 상황이다. 

왠만하면 예외를 throw하여 이를 받아서 처리하게끔 하는 것이 권장된다. 그런데 이런 예외를 throw하는게 불가한 경우가 있다. 왜냐하면~

**생성자에서 예외를 throw하면 소멸자가 호출되지 않는다!**

즉, 생성자에서 힙영역을 할당받고 소멸자에서 되돌려주는 식으로 설계를 했고, 생성자에서 힙영역을 할당받은 다음 예외를 throw한다면 메모리릭이 날 수 있다는 뜻이다.

이런 경우에는 객체를 생성하되 제대로된 객체가 아님을 확인할 수 있도록 해둔 '좀비객체'를 만들어서 처리하는 것도 방법이다.

[참고](https://isocpp.org/wiki/faq/exceptions#ctors-can-throw)

[참고2](https://isocpp.org/wiki/faq/exceptions#selfcleaning-members)



## 예외처리 팁

![try~catch](https://user-images.githubusercontent.com/54612343/91109765-e2b26580-e6b6-11ea-8a57-8303e51e2f3d.png)

위 캡처본은 line12가 실행될 때 'GradeTooLowException'이 throw되는 코드이다. line4에서 동적할당한 메모리주소를 `max_low` 포인터변수에 담고 있고, line14에서 delete하여 메모리 자원을 돌려주려는 의도로 작성된 코드이다. 그런데 이상한 점이 느껴지지 않는가? 결론부터 말하면 위 코드는 컴파일되지 않으며, 컴파일된다고 해도 메모리릭의 위험성을 가지고 있다.

#### 컴파일이 안된다고?

- try문 블럭내에서 정의&선언했던 변수는 try문 바깥에서 쓸 수 없다. 따라서 line19는 컴파일에러를 일으킨다. 만약 line19를 line21로 옮긴다고해도 마찬가지이다.

#### 메모리릭은 왜 나는데?

- 이런 상황에서 line12에서 에러가 throw되면, try 블럭안의 나머지 코드가 작동되지 않고, 바로 line16 catch문으로 진입하기 때문에 동적할당된 메모리주소를 잃어버리게된다. 결국 메모리릭이 발생한다!

#### 어떻게 해결하는가?

결과적으로 아래처럼 try~catch문 밖에서도 주소값을 보존하고, 동적할당 여부에 따라 delete여부를 결정하도록 코딩하였다.

![try~catch_advanced](https://user-images.githubusercontent.com/54612343/91110546-1f7f5c00-e6b9-11ea-8316-85f8b5feaec1.png)

- line1: 처음에 `max_low`변수를 try~catch문 밖에서 선언하며 nullptr를 정의해주었다. 이제 try~catch문 밖에서도 `max_low`변수에 접근할 수 있게 되었다.
- line5: try~catch문 밖에서 선언해둔 포인터에 동적할당한 주소를 저장한다. 동적할당을 실패할 경우 `bad_alloc`에러를 리턴하여 line20의 catch문에 진입하게 된다.
- line24: 만약 `max_low` 변수에 동적할당한 주소가 담겨있으면 delete하여 자원을 돌려준다.



## Tips

#### ex00

invalid한 점수로 Bureaucrat를 생성하면 `Bureaucrat::GradeTooHighException` , `Bureaucrat::GradeTooLowException` 예외를 던져야한다.

Bureaucrat 네임스페이스에 클래스가 선언되어있다는 말이고, 제출파일에 예외처리 클래스를 만들어둘 별도 파일이 포함되어있지 않으므로, 클래스안에 클래스를 만들어야한다.(중첩클래스)

거기다가 아래 블록에서 예외를 `catchable`하게 만들어야한다. 즉, try문에서 throw하는 예외가 `std::exception `타입의 참조자여야하는 것이다!

```c++
try
{
}
catch (std::exception& e)
{
}
```

아하 그럼 결국 Bureaucrat 클래스에 exception 클래스를 상속한 중첩클래스를 만들어야겠다!

*실제로 C++ 표준에서는 throw 문의 피연산자로 std::exception에서 파생되는 예외 타입을 사용하도록 권장하고 있다고 한다.*

#### exception 클래스?

여러 예외 클래스의 기초 클래스로 사용할 수 있는 exception 클래스를 제공한다. exception 클래스는 시스템에 따라 하나의 문자열 포인터를 반환하는 `what()`이라는 가상 멤버 함수를 제공한다. 가상함수니까 exception 클래스로부터의 유도클래스 내에서 재정의해서 쓸 수 있다ㅎㅎ



#### 생성자 예외검사 시점은?

생성자에서 예외를 throw하도록 만들고자 할 때, 예외검사 시점을 선택해야했다.

1. 멤버 이니셜라이저를 통해 초기화를 하고 멤버변수의 유효성을 검사하여 예외를 throw 하는 방법
2. 인자로 들어온 멤버변수의 유효성을 검사하고 유효하면 멤버변수에 `=`연산자로 값을 대입, 유효하지 않다면 예외를 throw해버리는 방법

처음 구현할 때는 '조기에 유효성을 검사하여 초기화하기도 전에 예외를 throw'하는 것이 가독성, 효율성 측면에서 좋을 것이고, 왠지 멤버이니셜라이저가 다 실행되고 나서 body를 실행하는 단계에서 에러를 throw하는 것이 '잘못하면 좀비객체를 만들 수도 있는거 아닌가?!' 하는 막연한 두려움이 들어서 2번 방법을 선택했다.

그러나 **1번 방법을 추천한다!** 이유는 ex01부터는 `const`멤버변수를 써야하고, 얘네는 선언과 동시에 정의해줘야한다는 특성상 어차피 **멤버이니셜라이저**를 통해서 초기화를 해줘야하기 때문이다. *이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성되기 때문!* 

그리고 '좀비객체를 만들 수도 있는거 아닌가?!'하는 막연한 두려움은 좀 더 알아보니 기우에 불과했다. 객체 생성이 자체가 아래 세 과정을 정상적으로 완료해야되는데, **3번이 완료되지 않아서 객체가 생성되지 않기 때문이다.**

1. 메모리 공간 할당
2. 이니셜라이저를 이용한 멤버변수(객체)의 초기화
3. 생성자의 몸체부분 실행

아 물론 이니셜라이저 실행시 heap 할당을 한다던가..하는 식으로 설계를 해놓았다면 3번에서 에러가 나더라도 이를 잘 반환하도록 코드를 설계해둬야 메모리릭을 방지할 수 있을 것이다.



#### ex01

- 지금까지는 assign 연산자 오버로딩시에 모든 멤버변수들을 복사시켜줬었는데, 이제는 `const`멤버변수가 포함되어있으므로 불가하다. (*복사생성자에서는 멤버이니셜라이저를 활용해왔으므로 기존방식대로 적용이 가능하다.*) 왜냐면, 처음 선언&정의 이후 변하지 않는 것.. 그것이 const니까!
  assign 연산자 오버로딩시에는 const변수를 제외하고 복사하는걸로  하자.

- signForm 함수에서 실행시키는 beSigned 함수에서 발생한 에러객체를 main함수까지 그대로 throw하고 싶다면? signForm 함수에 구현한 catch구문에서 인자 없이 `throw;`를 해버리면 된다.

#### ex02

- 특별히 새로운 개념은 없고 예외리턴을 고려한 객체설계 관련해서 고민해볼 수 있는 과제이다.
- `ShrubberyCreationForm` 클래스 , `RobotomyRequestForm` 클래스, `PresidentialPardon` 클래스간에 공통된 execute 함수의 예외체크 기능과 예외객체를 `Form`클래스에 구현해버리고, 이를 상속시켜버리자!

#### ex03

- 들어오는 인자에 따라 객체를 만들어리턴하는 `makeForm` 함수를 만들어야한다. 

- 문제는 지금까지는 1차원적으로 **if, else if, else if, else로 이어지는 조건제어문 branching**로 분기를 했지만 `makeForm `함수를 구현할 땐 **이게 금지되어있다**는 것이다. 쓰더라도 if문까지만 쓰고 else if나 else를 쓰면 안된다. 오호 그럼 어떻게 해야할까?🤔

- 객체를 생성하는 함수의 주소를 가지고 있는 '함수포인터배열'을 만들어서 활용하는 것이 좋을 것 같다. if문을 한번 써서 입력된 인자가 함수포인터배열의 어느 인덱스에 위치한 함수주소와 대응되는지 파악하면, 그 함수를 실행하며 결과값을 리턴하도록 하면 된다. *다른 동료들도 비슷하게들 접근했더라*

- 함수포인터 활용의 장점

  - 코드유연성 증가
    - 사용자가 인자, 리턴값을 맞춰서 함수를 정의하여 활용할 수 있도록 하기 때문.
  - 코드의 길이 감소

- 함수포인터 활용의 단점

  - 선언이 복잡하여 가독성이 떨어지기 쉽다.
  - C++의 장점인 inline화 코드가 안된다고 한다.
    - inline화란? 함수를 코드로 직접 대체하는 행위이고, 덕분에 함수 호출 비용이 없어진다. 여러 시점에 inline화가 이뤄지는데 자세한 건 [이 글](https://www.ikpil.com/821)을 참고하자.

  [참고](https://hwan-shell.tistory.com/87)

- 음? 그런데 더 공부해보니 함수객체와 lambda로 함수포인터의 단점을 개선할 수 있는 것 같다. 특히 lambda는 과제에서 금지되어있으니 과제가 끝난 다음에 써보자.

  [참고2](https://hwan-shell.tistory.com/86?category=703822)



# CPP Module 06

키워드: 타입변환 연산자

---

기존의 C스타일 형변환은 사용하기 쉽고, 강력한 대신, '의도에 맞지 않는 잘못된 형변환'을 컴파일단에서 잡아줄 수 없다는 문제가 있었다. 
가령 기초클래스의 포인터를 무작정 유도클래스의 포인터로 형변환하는 것이 가능한데, 그 포인터가 참조하는 객체가 기초클래스로 생성된 객체라면 유도클래스에만 있는 멤버함수를 실행하려는 순간 '정의되지 않은 동작'을 할 것이다. 이처럼 문법적으로 오류만 없으면 그냥 컴파일러가 형변환을 해버리니까 런타임에 에러가 발생할 확률이 높아진다. 이런 기존 C스타일 형변환의 문제점을 개선하기 위해 C++에서는 네가지 타입변환 연산자를 제공한다.

## C++의 네가지 타입변환 연산자

C++은 용도에 따라 네가지 타입의 연산자를 제공한다. 이제 개발자는 자신의 의도에 맞는 형 변환 연산자의 사용을 할 수 있고, 컴파일러는 요구한 형 변환이 적절치 않으면(의도에 맞지 않으면) 컴파일에러를 낼 수 있게 되었다!

#### 1. dynamic_cast

상속관계에서의 안전한 형 변환을 뜻한다. 상속관계에 놓여 있는 두 클래스 사이에서, **유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환**하는 경우 쓰인다. 

단, 기초 클래스가 **Polymorphic 클래스**인 경우엔 기초 클래스의 포인터 및 참조형 데이터도 유도 클래스의 포인터 및 참조형 데이터로 형 변환하는 것도 가능하다. Polymorphic 클래스는 하나 이상의 가상함수를 지니는 클래스를 뜻한다.

또한 런타임에 안정성을 검사하도록 컴파일러가 바이너리 코드를 추가로 작성한다. 그래서 실행속도가 조금 느려진다.

-  형태: `dynamic_cast<T>(expr)` 
  - T: 변환하고자 하는 자료형의 이름, 객체의 포인터 또는 참조형이 와야함. 
  - expr: 변환대상

#### 2. static_cast

dynamic_cast에서 허용하는 형 변환과 더불어 **기초 클래스의 포인터 및 참조형 데이터도 유도 클래스의 포인터 및 참조형 데이터로 형 변환**할 때와 **기본 자료형 간의 형 변환**에 쓰인다. 물론 이에 따른 책임은 개발자가 진다. dynamic_cast보다 static_cast가 연산속도가 빨라서 둘 다 쓸 수 있는 상황에서 일부러 후자를 쓰는 경우도 많다고 한다.

- 형태: `static_cast<T>(expr)`

#### 3. const_cast

const 선언된 참조자, 포인터의 const 성향을 삭제하는 용도로 쓰인다. const 선언의 의미가 값이 바뀌지 않는 것을 보장해주는 것이었는데 이 연산자 때문에 의미가 반감되는 느낌이다. 특별히 꼭 필요한 경우가 아니면 쓰지 않는 것이 좋다고 한다. 또한 컴파일러 최적화를 제한하는 validate 성향도 제거할 수 있다고 하는데, 이 부분은 솔직히 잘 모르겠다. 쓸 일이 생기면 더 자세하게 파보기로..

- 형태: `const_cast<T>(expr)`

#### 4. reinterpret_cast

전혀 상관없는 자료형으로 형 변환시에 사용된다. **포인터와 관련있는 모든 유형의 형 변환을 허용한다.**

- 형태: `reinterpret_cast<T>(expr)`



## Tips

### ex00

#### 제약사항

- C++ literal value(char, int, float, double)를 표현한 'string'을 인자로 받는 프로그램을 작성해야 한다.
- 프로그램은 1) 리터럴의 유형을 감지하고 2) 올바른 유형의 리터럴을 acquire한 다음**(이 시점에서 더 이상 문자열이 아니게된다.)** 3) char, int, float, double 네가지 유형으로 **명시적으로** 형변환한 뒤 그 결과를 출력하라.
- 10진법만 사용된다.
- char literal value의 경우, non displayble이면 이에 대한 notification을 출력해야한다.
- float literal value의 경우, -inff, +inff, nanf 같은 'pseudo literals'도 처리할 수 있어야한다.
  - Inf: 무한대
  - NaN: Not a number(숫자가 아님)의 약어. 실수나 복소수가 아닌 값을 나타냄.
- double literal value의 경우, -inf, +inf, nan 같은 'pseudo literals'도 처리할 수 있어야한다. 
- **각 cast situation 구현은 'specific cast'를 이용해서 해결되어야한다.**

#### 구현

- 문제 조건을 잘 보면 **1) 리터럴 유형을 감지하고, 올바른 유형의 리터럴 변수에 저장해야한다.** 이 때 오버플로우 에러를 검사하여 flag도 만들어주자.
- 이후에는 **2) 리터럴 변수에 저장해둔 데이터를 다른 리터럴 변수로 변환시켜야한다.** 즉, 최초에 프로그램에 넘겨준 인자의 type에 따라 char에서 다른 자료형들로, int에서 다른 자료형들로, float에서 다른 자료형들로, 그리고 double에서 다른 자료형들로 변환시키는 것이다. charToOther 같은 함수를 만들면 구현이 쉽고 빠를 것 같다.
- **3) 이제 변환하며 생긴 예외들, +-, inf, inff, nan, nanf 등을 신경쓰며 출력해주자. ** 
- char
  - ascii의 non-printable인 경우와 아닌 경우를 주의하자.
  - 처음에는 프로그램에 인자로 `'1'`을 전달하는 경우에 문자 '1'로 인식하여 `char: 1 ` 이런 식으로 출력시켜야한다고 생각했는데, bash/zsh에서 프로그램에 인자를 전달하는 방식 자체를 바꿔야하는 것이므로 패스하였다.
- int
  - 제일 먼저 구현시작. 최초 인자로 받아온 string value를 int로 형 변환해본다. 문제는 static_cast로는 기본자료형간에 형 변환만 지원한다는 것이다. 
  - **`std::stoi()`는 C++11에 추가된 함수여서 사용이 금지되어있다.** 아.. 이런 멀쩡히 있는 함수를 못쓰는거 정말 싫은데.. 하나하나 C++11에 추가된 함수인지 확인하는 것도 귀찮다. 그냥 `std::stringstream`을 이용하거나 c언어에서 문자열->literal 형변환에 쓰이는 함수들을 써버리자.
- float
  - overflow를 확인하려고 아래처럼 코딩했었는데, input으로 들어온 문자가 'char'형이면 바로 double로 변환되지 않아서 에러가 생겼었다. 못생겼지만.. int로 캐스팅했다가 double로 캐스팅하자.
  - 그리고.. float 최소값을 체크하기 위해 `std::numeric_limits<float>::min()`을 쓰면 한없이 0에 가까운 **양수값**이 나온다. 최소값을 찾으려면 **lowest함수를 써야한다.** 이제사 알게되어 좀 부끄러운걸? [참고](https://aker.tistory.com/596)
  - inf, inff, nan, nanf를 모두 받아야하는데, float 변수에 담을 수 있는 값은 아닌 것 같아서 예외로 처리했다.
- double
  - float이랑 거의 동일하다 복붙하고 세세한 것만 바꿔주자.

엄.. 개인적으로 이거 구현하다가 맘이 급해져서 막 코딩해버린 감이 있어서 아쉽다. 좀 더 여유를 가지고 아키텍처를 생각하고 코딩을 시작해야겠다.

### ex01

#### 요구사항

자 딱 봐도 쉬워보이는 과제가 나왔다.

- `void *serialize(void)` : 랜덤한 8개의 알파벳으로 이뤄진 s1, 랜덤한 8개의 숫자로 이뤄진 n, 그리고 다시 랜덤한 8개의 알파벳으로 이뤄진 s2를 heap에 할당하여 그 주소를 반환한다. 이 때 s1, n, s2가 연속된 메모리에 위치해야한다.
- `Data *deserialize(void *raw)` raw에 저장된 serialized data를 세 종류로 나누어서 아래 구조체에 저장한 후 그 주소를 반환한다. `struct Data {std::string s1, int n; std::string s2;}`

#### 구현방향

1. 우선 s1, n, s2를 한번에 저장할 수 있게끔 heap을 할당한다.
2. 할당한 주소에 랜덤한 값을 요구사항에 맞게 넣고, 그 주소를 리턴하여 `void *raw`에 넣는다. 
   - reinterpret_cast를 쓰자!
3. 이후 deserialize에 인자로 `void *raw`를 받아와서 적절히 형 변환하여 data에 넣자.
   - [std::string 생성자](https://modoocode.com/237)를 참고하자.

