# Philosophers

Rules를 따르면서 철학자들이 스파게티 먹고 사색에 잠기도록 해주자. 한명이라도 죽으면 프로그램이 끝나므로 다 먹지 못할 것이다.

### Basic Rules

3개의 독립적인 프로그램을 만들어야한다. 3개의 프로그램은 아래의 기본룰을 따른다.
- 철학자는 테이블 주위에 앉아서 'eating, thinking, or sleeping' 중 하나의 동작을 한다.
- 한가지 동작 중엔 다른 동작을 할 수 없다. 
- 테이블은 둥근 형태이며 가운데에 스파게티 접시가 있다.
- 테이블 위에 포크가 올려져있다.
- 스파게티는 집기 어렵기 때문에, 철학자는 두 손에 각각 포크를 들고 스파게티를 집어야한다.
- 철학자는 결코 굶주리면 안된다.
- 모든 철학자는 먹어야한다.
- 철학자는 다른 이와 대화를 나누지 않는다.
- 철학자는 다른 철학자가 죽었는지 알 수 없다.
- 각 철학자는 식사를 마치면 포크를 내려놓고 수면을 취한다.
- 철학자는 수면을 마치면 사색에 잠긴다.
- 이런 상황은 철학자가 죽으면 끝난다.
- 각 프로그램은 동일한 옵션을 가지고 있어야한다.
    - number_of_philophers: 철학자와 포크의 개수. 이걸 생각하면, 철학자가 한명인 경우에는 식사가 불가해서 죽어버릴듯.
    - time_to_die: 철학자가 마지막 식사를 마치고 다음 식사를 마치기 전에 'time_to_die' milliseconds만큼 시간이 지나거나, 시뮬레이션을 시작하고 'time_to_die' milliseconds만큼 시간이 지나면, 철학자는 죽는다.
    - time_to_eat: 철학자가 먹기 시작하고 마치는데 걸리는 시간. 먹는 동안 철학자는 두개의 포크를 쥐고 있다. milliseconds 단위.
    - time_to_sleep: 철학자가 수면을 시작하고 마치는데 걸리는 시간. millisecond 단위.
    - [number_of_times_each_philosopher_must_eat]: 이 옵션인자는 선택적으로 주어진다. 만약 모든 철학자가 적어도 'number_of_times_each_philosopher_must_eat'시간만큼 먹었다면 시뮬레이션은 멈춘다. 만약 이 옵션이 설정되지 않았다면, 시뮬레이션은 철학자가 죽을 때에만 끝난다.
- 각 철학자는 1에서 'number_of_philosophers'까지의 번호를 받는다.
- 1번 철학자는 'number_of_philosophers'번 철학자 다음에 앉아있다. N번째 철학자는 N-1번째 철학자와 N+1번째 철학자 사이에 있다.
- 철학자의 상태변화는 하단과 같이 적혀져야한다. 이 때 'X'는 철학자의 번호로, 'timestamp_in_ms'는 milliseconds로 표현된 current timestamp로 갈음되어야한다.
    - timestamp_in_ms X has taken a fork
    - timestamp_in_ms X is eating
    - timestamp_in_ms X is sleeping
    - timestamp_in_ms X is thinking
    - timestamp_in_ms X died
- 한 철학자의 상태표시는 다른 철학자의 상태표시와 섞이거나 방해받으면 안된다.
- 철학자의 죽음과 그 죽음을 표시하는 사이에 10 ms 초과의 시간이 지나면 안된다.
- 다시한번 강조하건데, 철학자는 죽음을 피해야한다!

### Philosopher one

허용된 함수는 아래와 같다.
    - memset
    - malloc
    - free
    - write
    - usleep: sleep과 달리 microseconds를 인자로 받음. [man usleep](https://man7.org/linux/man-pages/man3/usleep.3.html)
    - gettimeofday: [man gettimeof]
    - pthread_create
    - phtread_detach
    - pthread_join
    - pthread_mutex_init
    - pthread_mutex_destroy
    - pthread_mutex_lock
    - pthread_mutex_unlock

Philosopher one을 만들기 위해 학습해야할 키워드는 아래와 같다.
- threads
- mutex

하나씩 학습해보자.
먼저 쓰레드는 **프로세스의 실행단위**이다. 따라서 쓰레드를 이해하려면 프로세스에 대한 이해가 선행되어야한다. 그리고 뮤텍스는 쓰레드의 동기화 방법의 종류 중 하나이다. 쓰레드를 이해하고 학습하자.

# 프로세스?

**프로세스는 프로그램이 실행되는 단위**이다. 또한 다른 말로 사용자가 작성한 **프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것**을 말한다. '실행 중인 것'이라는 말은 프로세스가 시작하고 종료하는 생명주기를 가지는 것을 내포한다. 
이미 minishell을 진행하며 많이 학습하였으므로 생략한다. 자세한 내용은 [위키](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)와 [이 링크](https://bowbowbow.tistory.com/16)를 참고하자.

# 쓰레드?

![image](https://user-images.githubusercontent.com/54612343/88770779-441b0d80-d1b9-11ea-82a0-eeb9abd68a4f.png)


쓰레드는 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다. 모든 프로세스는 한 개 이상의 쓰레드가 존재하여 작업을 수행한다. 또한 두 개 이상의 쓰레드를 가지는 프로세스를 멀티쓰레드 프로세스라고 한다.

프로세스는 하나의 어드레스 공간을 가지고 있고, 쓰레드들은 자신을 관리하는 프로세스의 어드레스를 가지며 그 프로세스를 구성한다. 만약 서로 다른 쓰레드가 같은 프로세스를 구성하고 있다면, 그 프로세스에 할당된 메모리, 자원 등을 공유하게 된다. 이 관점에서 보면 프로세스는 쓰레드에 대한 일종의 컨테이너 역할을 한다고 할 수 있다.

한편 각 쓰레드별로 자신만의 스택과 레지스터를 가진다. (프로세스 자원을 공유하더라도 독립적인 작업을 수행해야하기 때문)

쓰레드는 프로세스처럼 실행, 준비, 대기 등의 실행 상태를 가지며, 실행 상태가 변할 때마다 **context switching**을 수행한다.

한 순간에 하나의 쓰레드만이 실행가능하다.

## 쓰레드의 장점

- 쓰레드는 프로세스보다 생성 및 종료시간, 쓰레드간 전환시간이 짧다.
- 쓰레드는 프로세스의 메모리, 자원등을 공유하므로 커널의 도움없이 상호간에 통신이 가능하다.

## 쓰레드 동기화 방법의 종류

- Mutex
    - mutex 는 Mutual exclusion의 악자로, 상호배제라는 뜻이다.  critical section을 가진 thread들의 running time이 서로 겹치지 않게, 각각 단독으로 실행되게 하는 기술이다.
    - **임계영역**에 들어가기 위해서는 이 뮤텍스를 가지고 있어야한다. 임계영역에 들어간 쓰레드가 뮤텍스를 이용해 임계영역에서 본인이 나올 때까지 다른 쓰레드가 못 들어오게 내부에서 뮤텍스(마치 자물쇠 잠그듯)로 배제시킨다.
- Semaphore
    - 뮤텍스와 비슷하지만 동시 접근 도익화가 아닌, **접근 순서 동기화**에 더 관련있다.
- Monitor
    - Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다.

- [참고](https://goodgid.github.io/What-is-Thread/)
- [참고2](https://elky.tistory.com/197)

## 쓰레드 기아상태

- [참고](https://it-mesung.tistory.com/175)

# 세마포어

- 작동원리
  - 차단을 원하는 자원에 대해서 세마포어를 생성하면, 해당 자원을 가리키는 세마포어 값이 할당됨. 이 세마포어 값을 검사해서 임계영역에 접근할 수 있는지를 결정하게 된다.
  - 세마포어 값이 0이면 자원에 접근 불가, 0 초과인 정수면 해당 정수의 크기만큼의 프로세스가 자원에 접근할 수 있다.
  - 결론적으로 아래와 과정을 따른다.
    1. 임계영역을 설정함.
    2. 임계영역에 진입하기 전에 세마포어 값을 확인
    3. 세마포어 값이 0보다 크면 세마포어를 가져옴. 세마포어를 가져왔으니 커널의 입장에서 세마포어가 1 감소한다.
    4. 세마포어 값이 0이면 값이 0보다 커질때까지 block 되며, 0보다 커지게 되면 2번부터 시작하게 된다.

세마포어는 원자화(시그널의 도착에 의해 작업이 중단되지 않으며, 한 순간에 오직 하나의 프로세스만이 자원에 접근하는 것을 말한다.)된 연산을 필요로 한다. 원자화된 연산은 유저레벨의 함수에서는 제공하기가 힘들어서 커널에서 전용 구조체를 이용해서 관리하게 된다.



전통적으로는 SYstem V 인터페이스가 있고, 우리 과제에서 주어진 것은 POSIX 규격을 따르는 세마포어 인터페이스에 속한 함수들이다. 

## POSIX 세마포어

POSIX 세마포어 함수를 사용하기 위해서는 -lrt로 리얼타임 라이브러리를 링크해야한다. 아래처럼!

`gcc -lrt test.c`

### 세마포어 만들기

세마포어는 'unnamed semaphore'와 'named semaphore'로 나누어져있다.

전자는 `sem_init`으로 만들고 후자는 `sem_open`으로 만든다. 과제에는 `sem_open`만 허용되어있다. 

'named semaphore'는 마치 세마포어 객체를 파일처럼 관리한다. *정확히 파일은 아니어서 read/write/close 함수를 쓸 수는 없다고 한다.* 

인자는 다음 4개이다.

- name: 서로 구분되는 세마포어의 이름
- oflag: 세마포어 생성을 위해 O_CREAT로 설정된다. (이미 세마포어가 존재하는 경우 실패하게하려면 O_EXCL로 설정함.)
- mode_t: 새로운 세마포어에 대한 권한을 제어한다.
- value: 세마포어의 초기 값을 결정한다.

리턴 값은 'sem_t' 구조체이다.



세마포어 파일은 /dev/shm에 만들어진다. 그러므로 아래처럼 /dev/shm을 마운트 시켜줘야 한다.

`# mount /dev/shm`

#### 세마포어 얻기(기다리기)

세마포어를 얻을 때까지 기다린다. `sem_wait`, `sem_trywait`, `sem_timedwait`가 있고, `sem_wait`함수만 과제에 허용되어있다.

sem_wait 함수는 세마포어 값이 0보다 크면 프로세스가 세마포어를 얻고, 세마포어를 감소한다음 즉시 반환한다. 만약 세마포어값이 0이라면 세마포어가 0보다 더 커지거나 시그널이 발생할 때까지 대기한다. *흡사 mutex_lock 같은 느낌*

#### 세마포어 되돌려주기

`sem_post`함수로 세마포어를 되돌려준다. 세마포어 값이 하나 증가한다. *흡사 mutex_unlock 같은 느낌*

#### 세마포어 삭제

`sem_unlink` 함수로 세마포어를 삭제하고, **OS에 자원을 반환**한다. 이 때 바로 반환되는 것은 아니고 해당 세마포어를 참조하는 프로세스가 모두 없어져야 비로소 세마포어 객체가 사라진다고 한다. `sem_open`으로 만든 'named 세마포어'를 삭제하고자 할 때 사용한다.

`sem_unlink` 를 호출한 이후에 `sem_close`함수를 호출하여 종료하면 끝! http://neosrtos.com/docs/posix_api/semaphore_close.html

만약 개발자가 세마포어를 close하는 동작을 잊는다면, 세마포어 cleanup은 **프로세스 종료시점**에 이루어진다고 한다. 요건 POSIX 세마포어의 특징이다.



## 세마포어와 뮤텍스의 차이점

1. 세마포어는 뮤텍스로 사용될 수 있지만, 뮤텍스는 세마포어로 사용될 수 없다.
2. 세마포어와 뮤텍스는 모두 본래 비 재귀적이다.
3. 세마포어는 소유할 수 없는 반면 뮤텍스는 소요 가능하며 소유주가 이에 대한 책임을 진다.
4. **뮤텍스는 뮤텍스를 소유하고 있는 쓰레드가 이 뮤텍스를 해제해야 한다. 그러나 세마포어의 경우 이러한 조건이 필요치 않다. 임의의 다른 쓰레드가 함수 sem_post()를 사용하여 세마포어를 해제하기 위한 신호를 보낼 수 있다.**
5. 정의에 따라 뮤텍스는 하나 이상의 쓰레드에 의해 동시에 실행되지 않도록 재진입코드 부분에 대한 접근을 시리얼화 하기 위해 사용한다.
6. 세마포어는 시스템 범위에 걸쳐 있어서 파일 시스템상의 파일 형태로 존재한다. 반면 뮤텍스는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 clean up된다. 다만, POSIX 세마포어는 일관성없게도 프로세스 종료시점에 clean up되는 특징을 가지고 있다.
7. 세마포어의 본래 목적은 쓰레드 뿐만 아니라 관련 혹은 비 관련 프로세스를 동기화 하는데 있다. 반면 뮤텍스는 쓰레드간의 동기화에만 사용되어왔고 최근 커널에서야 관련(related) 프로세스에서 사용가능하게 한다.
8. 세마포어를 사용하는 프로그램이 뮤텍스를 사용하는 프로그램에 비해 좀 더 많은 메모리를 사용한다.
9. 사용면에서는 뮤텍스가 세마포어에 비해 좀 더 간단한 사용법을 갖는다.



[참고](https://www.joinc.co.kr/w/Site/system_programing/IPC/semaphores)

[참고2](https://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS5536818490)



# 내가 만난 문제들

#### 문제) mutex destroy를 할 때 해당 mutex가 unlock되어있는 것을 어떻게 보장할 것인가?

#### 해결) 프로그램 종료조건 만족 후 flag를 바꾸면, 각 쓰레드가 모든 mutex가 잠금된 상태에서 메인쓰레드가 종료될 때까지 무한대기하도록 만들었다.

#### 문제) 중간에 프로그램이 종료되고, 종료시점에 따라 생성된 쓰레드 개수가 다르다면, destroy할 mutex 개수를 어떻게 확인하는가?

#### 해결) 모니터 쓰레드를 생성하다가 종료되는 경우, 철학자 쓰레드를 생성하다가 종료되는 경우, 그리고 두 쓰레드를 생성하기 전에 종료되는 경우로 케이스를 나누어서 destory할 mutex 개수를 구하고, 이를 바탕으로 destroy하도록 만들었다. 흠.. 그런데 지나고보니 mutex 포인터를 모두 NULL로 초기화해두고, 쓰레드 생성에 성공한 경우에만 mutex_init을 실행하여, NULL이 아닌 경우에만 destroy하도록 만들었으면 간편하게 처리할 수 있었다는 생각이 든다. 

#### 문제) gettimeofday 함수 에러를 어떻게 처리할 것인가?

#### 해결) gettimeofday 함수 에러가 났을 때 프로그램 작동에 영향을 크게 미치는 상황과 그렇지 않은 상황을 나누어서 전자는 error를 리턴하고 종료되게끔 만들었고, 후자는 출력 메세지 내용만 조금 바뀌는 것이라 무시하기로 판단했다.

#### 문제) 세마포어를 쓰고서, must_eat_count의 수를 0에서 1로 바꾸었음에도 불구하고 0으로 설정한 것과 동일하게 작동하였다.
#### 해결) `sem_open` 함수를 작동시키고 나서 제대로 `sem_unlink`가 되지 않아서 생긴 일로 확인되었다. `ft_sem_open` 함수를 만들어서 `sem_unlink`를 한 뒤 `sem_open` 하는 것으로 수정하여 해결하였다.

#### 문제) `5 800 200 200`을 했을 때 죽는 경우가 있다.
#### 해결) 모든 철학자가 왼쪽, 오른쪽 순으로 포크를 들도록 만드는 대신, 홀수번째 철학자가 먼저 식사를 시작하고 이후에 짝수번째 철학자가 식사를 시작하도록 조절하여 환형대기를 끊었다.

기존 포크픽업 알고리즘에 문제가 있었다. 홀수번째 철학자는 왼쪽 포크부터, 짝수번째 철학자는 오른쪽 포크부터 들도록 만들어두었는데, 이를 통해 환형대기를 끊어서 **dead lock은 해결**할 수 있었지만, **starvation을 해결할 순 없었다.** 가령 5명의 철학자가 있고, 1번 3번 철학자가 먼저 식사를 시작했다고 가정했을 때 2번 철학자는 확정적으로 식사를 하지만, 4번 5번 철학자 중 한명은 랜덤하게 식사를 하게 된다. 이 랜덤성 때문에 식사를 해야하는 배고픈 철학자 대신 이미 뱃속에 스파게티가 반쯤 차있는 철학자가 식사를 재차하는 상황이 발생하는 것이다. 
이런 현상을 방지하기 위해 포크를 드는 순서를 조정하는 것이 아닌, 포크를 드는 순간을 조정하여 해결하였다.

#### 문제) philo_three 철학자를 199명 만들면, 죽는 시점이 10초이내인 것을 보장되지 않는 경우가 발생한다!
#### 해결) 터미널에 출력하는 과정에서 병목이 발생한다는 것을 알게되었다. log.txt 등의 파일에 출력을 보내어서 병목을 없애며 시연하기로 결정하였다.

#### 문제) philo_three 철학자를 199명 만들면, 어마어마한 leaks가 생긴다.
#### 해결) 

한편 인터넷에 있는 다른 learner들의 과제들을 보면 이걸 제대로 처리한 과제가 드물다.. 어떻게 통과한거지.. 동료평가가 약했남; 여튼 실행 중인 프로세스들에 SIGKILL 시그널을 보냈을 때 제대로 free하고 종료하지 않는 것이 원인이었다. `signal 함수`가 허용되어있었다면 `clean up` 함수를 signal handler로 연결시켜서 쉽게 처리할 수 있었을텐데 허용되어있지 않아서 다른 방법을 생각해야했다.

